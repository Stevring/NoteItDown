# 程序员的自我修养

## 第2章 编译和链接

### 2.1 被隐藏了的过程

1. 从代码到可执行程序，经历了四个步骤：预编译、编译、汇编、链接

   1. 预编译

      主要处理以`#`开始的预编译命令，比如`#import"`，`#include`

   2. 编译

      将预编译得到的文件进行词法分析、语法分析、语义分析和优化，生成汇编代码。

   ---

   现代编译器将预编译和便衣合为一个步骤。对不同的语言有不同的程序完成该工作。

   ----

   

   3. 汇编

      将汇编代码翻译成机器指令，得到目标文件。

   4. 链接

      将多个目标文件链接到一起，得到最终的可执行文件.

### 2.2 编译器做了什么

很好理解

### 2.3 链接器年龄比编译器长





## 第3章 目标文件里有什么

### 3.1 目标文件的格式

1. 目标文件是编译器对源代码加工后的产物，其存储格式与可执行文件相同，只不过还没有进行链接。可以广义地将二者看作一种文件：

   Win的可执行文件：PE（Protable Executable）

   Linux的可执行文件：ELF（Executable Linkable Format）

   Mac：Macho （Macintosh Object ？）

   除此外，静态链接库（win的.lib，linux的.a）、动态链接库(win的.ddl，linux的.so)也按照可执行文件格式存储。

2. ELF文件分类：

<img src="https://raw.githubusercontent.com/Stevring/Pics/main/ELF%E6%96%87%E4%BB%B6%E7%9A%84%E7%B1%BB%E5%9E%8B.png">



可以使用`file`命令查看文件类型。



### 3.2 目标文件是什么样的

1. 目标文件将各类信息按照不同属性存储在不同的段。比如：
   - 编译后的机器指令：代码段（.code or .text）
   - 经过初始化的【全局变量和局部静态变量】：数据段（.data）
   - 未初始化的【全局变量和局部静态变量】：.bss段（bss = Block Start by Symbol ）
2. 目标文件最开始的文件头存储了整个文件的属性，如
   - 是否可执行、静态链接还是动态链接、目标硬件、目标操作系统
3. 紧接着文件头的是段表：一个数组，描述了各个段在文件中的偏移及属性
4. 为什么要分段？
   - 对不同的段设置不同的读写权限，防止恶意篡改
   - CPU有数据缓存和指令缓存，分段可提高CPU缓存命中率
   - 当这个程序存在多个副本时，可共享代码段，减少内存占用



### 3.3 挖掘SimpleSection.o

1. `gcc -c main.c` 只编译为目标文件，不链接

2. 使用`objdump`命令查看目标文件的相关内容

   如`objdump -h main.o` 打印目标文件的段信息

   <img src="https://raw.githubusercontent.com/Stevring/Pics/main/%E6%AE%B5%E4%BF%A1%E6%81%AF.png" width="60%">

3. `size main.o` 查看目标文件各个段的大小

4. `objcopy` 把一种目标文件中的内容复制到另一种类型的目标文件中



https://opensource.apple.com/source/cctools 这里的load.h详细解释了 mach-o 文件头的格式：

1. 最开始是 mach-header
2. 接着是 load_command



mach-o 文件里的` __TEXT, __cstring` 段保存了字符串常量，但是怎么记录每个字符串的offset呢

以及symbol table 里的symbol offset



## 第4章 静态链接

链接就是将多个目标文件拼接为一个整体可执行文件

### 4.1 空间与地址分配

输出文件中的空间如何分配给输入文件？

1. 按序叠加

   将每个输入文件直接按序拼接起来。这会导致输出文件中有很多零散的段。

2. 相似段合并

   将每个输入文件中相同的段合并到一起。

目前的编译器采用后一种方式。合并之后链接器会重新计算每一个符号的虚拟地址。



### 4.2 符号解析和重定位

1. 重定位：在链接之后，因为每个符号的地址变了，所以在对这些符号引用的地方也需要修改地址。

2. 如何知道哪些指令需要被修改呢？

   使用重定位表。对于每一个需要修改符号地址的段，都会有一个对应的重定位表，每一个表项纪录了需重定位的符号在这个段的偏移。
   
   使用MachOView可以查看MachO的重定位表
   
3. 指令修正方式。

   众所周知指令的寻址方式有绝对寻址、相对寻址、寄存器寻址....等方式。下面针对绝对寻址和相对寻址探讨如何对指令进行修正。

   设符号原地址为 `old_addr`，链接后的新地址为`new_addr`，指令中原来存在的值为`offset`

   绝对寻址：指令中修正后的地址为`new_addr + offset`

   相对寻址：指令中修正后的地址为`new_addr - old_addr + offset`
   
   思考：extern全局变量是否只能用绝对寻址？

### 4.3 弱符号与强符号 3.5.5   COMMON块 4.3** 需要和库一起看一下

### 4.4 C++相关问题

1. 重复代码消除、函数级别链接

   1. 重复代码消除。C++的模板、虚函数等可能在不同目标文件中都被实例化，所以链接的时候会有多段重复代码。链接时会对这类代码消重。
   2. 函数级别链接。一个目标文件中可能有很多函数和变量，如果只引用其中一个，那么整个文件都被链接，最终目标文件中增加了很多没用到的东西。函数级别链接就是将每个函数作为一个段，只链接用到的段。（对于变量也有类似的操作）

2. 全局构造和析构。

   在main执行前和执行后可能需要进行必要的初始化和扫尾工作。`.init`和`.fini`段分别定义了这两段工作的代码。

3. 

### 4.5 静态链接库

1. 库的概念：一组目标文件的集合，由多个目标文件压缩打包后形成。
2. 程序在链接时，将静态链接库解压，并将用到的目标文件链接即可，减少了不必要的链接。



## 第6章 可执行文件的装载与进程

### 6.1 进程虚拟空间

进程都运行在虚拟地址空间下。虚拟地址空间大小由处理器的位数决定，如32位处理器的最大寻址空间为4GB，那么进程理论上可以使用的最大虚拟空间即为4GB。然而实际上由于操作系统运行和其他的原因，只有一部分虚拟空间分配给了进程，如Win上分配了2GB。



如果进程需要的空间大于操作系统分配的空间咋办？

1. 窗口映射。物理硬件拥有大于4GB的内存，程序需要时向操作系统申请。申请后操作系统将这段额外的物理空间映射到某一段固定的虚拟地址空间。程序访问这段固定的虚拟地址空间即可。Linux下使用`mmap`系统调用实现。（好熟悉的名字）
2. 使用更大的处理器位数和物理内存。:smile:



### 6.2 装载的方式

程序需要装载近内存才能运行。

1. 覆盖装入。程序分为多个模块，假设模块A、B之间没有相互调用，那么当程序需要A的时候将A装入，需要B的时候可以将B覆盖装入到A所在的空间。以此节省内存。
2. 页映射。



### 6.3 从操作系统角度看可执行文件的装载

1. 进程的建立
   1. 创建一个独立的虚拟地址空间
   2. 读取可执行文件头，并建立虚拟地址空间与可执行文件的映射关系
   3. 将CPU的指令寄存器设置为可执行文件的入口地址，启动运行。
2. 虚拟内存区域（Virtual Memory Area, VMA）
   1. 进程虚拟地址空间中的一个段叫VMA。每个VMA都对应了链接后的可执行文件中的一个段，当发生页错误时，操作系统会根据VMA和可执行文件段的映射关系，从可执行文件中读取所需页装载进内存。

### 6.4 进程虚拟空间分布

1. Segment 和 Section 的区别
   1. 在目标文件中，每一段都称为一个Section
   2. 为了减少内存碎片，操作系统会将读写权限相同的Section组成一个Segment，并将一个Segment映射为一个VMA。
2. 堆和栈
   1. 堆和栈在虚拟地址空间中也分别映射到了一个VMA。



## 第7章 动态链接

1. 静态链接的缺点。

   1. 浪费磁盘空间和内存。比如 printf.o 这种公共库，几乎每一个程序都要用到，那么该程序的可执行文件中就链接了 printf.o 的一个副本。对于动辄上千个程序的操作系统来说，这样的浪费累积起来非常大。
   2. 不利于版本更新和发布。加入软件A依赖于20个外部厂商提供的库，那么每一个库更新后，A就必须重新链接并发布给用户。

2. 动态链接。

   1. 概念：当运行程序A时，发现其依赖于B.o，再将B.o加载进内存。当所有依赖文件都加载完成后开始链接。最后开始执行程序。即 将程序的链接推迟到运行时。
   2. 优点
      1. 可兼容性。如果Win和Mac上都有printf.o，但实现机制不同，A程序依赖于printf.o。那么使用静态链接，A需要分别在Win和Mac上链接，并发布两个不同版本。但动态链接只需Win和Mac提供的printf.o遵循相同的接口，就只需发布一次.

3. 动态链接的过程

   假设 Program1.c 和 Program2.c 都用到了 Libc.c。

   1. 将Libc.c编译成共享链接对象文件：`gcc -fPIC -shared -o Libc.so libc.c`
   2. 将Program1.c动态链接 `gcc -o Program1 Program1.c ./Libc.so`

   - 为什么在生成Program1可执行文件的时候，Libc.so也需要作为链接器的输入呢？不是说动态链接这一步推迟到了运行时吗？
     - 假如Program1.c用到了Libc.c中的函数foo，那么将Program1.c编译链接为可执行文件的时候，按照静态链接的规则需要对foo进行重定位，但由于采用了动态链接的方案，链接器只会将foo标记为动态链接符号。将Libc.so作为输入，是为了让链接器知道定义在Libc.so中的符号是动态链接符号。
   - 动态链接得到的可执行文件Program1装载进内存后的虚拟地址空间分布？
     - 操作系统将 Program1 、Libc.so、动态链接器 ld-2.6.so 以及其他用到的动态链接库按照同样的方式映射到进程的虚拟地址空间。
   - 

   



