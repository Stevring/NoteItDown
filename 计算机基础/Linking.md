# Notes on CSAPP: Linking

## 7.1 Compiler Driver

Compiler driver is a program that invokes a series of actions to turn the input source code into executable files. Typical actions include language preprocessing, compiling, assembling and linking.

On the MacOS system, the compiler driver is `clang`.

1. Language preprocessing only

   `clang --preprocess main.c --output main.i `

2. Language preprocessing + compiling

   `clang --assemble main.c --output main.s`

3. Language preprocessing + compiling + assembling

   `clang --compile main.c --output main.o`

4. Language preprocessing + compiling + assembling + linking

   `clang main.c --output main.out`

## 7.2 Static Linking

Static linkers takes a bunch of relocatable object files as input, and links them into an executable object file that can be loaded and run. Static linking consists of two main tasks:

1. Symbol resolusion
   1. Each symbol corresponds to a function, global variable or a static variable (local variables are not included).
   2. The purpose of this task is to associate each symbol reference to exacly one symbol definition.
2. Relocation
   1. Each section in a relocatable object file starts at address 0. Relocation assigns an actual memory to each section and modify all references of symbols located in it.

## 7.3 Object Files

Three types of object files:

1. Relocatable object file
   1. Generated by compilers and assemblers.
   2. Can be combined with other relocatable object file to create an executable object file.
2. Exexutable object file
   1. Generated by linkers.
   2. Can be directly loaded into memory and run.
3. Shared object file
   1. A special type of object file that can be linked dynamically at load time or run time.

## 7.4 Mach-O Relocatable Files

Structure of Mach-O relocatable files:

```C
|------------------------------| 0x00
|       Mach Header            | Defines the Magic Number, CPU Type, etc.
|------------------------------| 0x20
|       Load Commands          |
|------------------------------|
|          Sections            |
|------------------------------|
|        Relocations           |
|------------------------------|
|       Symbol Table           |
|------------------------------|
|       String Table           |
|------------------------------|
```





## 7.5 Symbols and Symbol Tables

Three type of symbols in the context of a linker:

1. Global Symbol. Defined by module m and can be referenced by other modules.
2. Extern Symbols. Refereced by module m but is defined by other modules.
3. Local Symbols. Defined and referenced by module m only.

**Note: Definition of symbols is different from programme variables.**

```C
/*
 * Programme - main.c
 */
extern int external_var;
static int static_var = 0;
int global_init = 0x99;

int main () {
	static int static_var_init = 0x88;
	int i = 9;
  static_var = 90;
  static_var_init += 2;
  static_var += 10;
	return i + static_var_init + static_var + global_init;
}
```

For programme `main.c`, global symbols are `global_init` and `main`. Only `external_var` is an Extern Symbol. Local Symbols are `static_var` and `static_var_init`.



Structure of symbol table entries:

```c
/*
 * This is the symbol table entry structure for 64-bit architectures.
 * In header <mach-o/nlist.h>
 */
struct nlist_64 {
  union {
		uint32_t n_strx; /* index into the string table, which is an array filled with null-terminated string names */
  } n_un;
  uint8_t n_type;    /* type flag */
  uint8_t n_sect;    /* section number or NO_SECT (equals 0) */
  uint16_t n_desc;    /* see <mach-o/stab.h> */
  uint64_t n_value;   /* value of this symbol (or offset from start of the __text section) */
};
```



symbol table of main.c:

![image-20201006150531911](https://raw.githubusercontent.com/Stevring/Pics/main/symbol_table_main_c.png)



Two similar sections:

COMMON: Uinitialized global variables

.bss: Uinitialized static variables, and global or static variables initialized to zero.



## 7.5 Symbol Resolution

As different modules may define symbols with the same name, the process of symbol resolution is to associate each symbol reference to exactly one symbol definition. 

At compilation time, the compiler exports each global symbol as either strong or weak (the type field in symbol table entries):

- Strong symbols
  - Functions
  - initialized global variables

- Weak symbols
  - Uinitialized global variables

If duplicate symbol definitions are found, linkers choose one of them for each reference with the following rules:

1. Multiple strong symbols. Not allowed.
2. One strong symbol and multiple weak symbols. Choose the strong one.
3. Multiple weak symbols. Choose any of them.



```C
// Example for rule 2

/*
 * main.c
 */

void trigger_bugs(void);

int x = 1;
int main()
{
  trigger_bugs();
  printf("%d", x);
  return 0;
}

/*
 * a.c
 */

int x;
void trigger_bugs(void)
{
  x = 2;
}
```



```C
// Example for rule 3

/*
 * main.c
 */

void trigger_bugs(void);

int x;
int main()
{
  x = 1;
  trigger_bugs();
  printf("%d", x);
  return 0;
}

/*
 * a.c
 */

int x;
void trigger_bugs(void)
{
  x = 2;
}
```



## 7.7 Relocation

After symbol resolution, each symbol reference in the code is associated with one symbol definition (i.e., a symbol table entry in one of the input mudules). Now it comes to the phase of relocation.



For each symbol reference, the compiler generates a relocation entry in the relocation table. The load command of each section tells you the offset of the start of its relocation entries and how many relocation entries this section has.

![](https://raw.githubusercontent.com/Stevring/Pics/main/reloc_info_in_load_command.png)



Structure of a Mach-O relocation entry:

```C
struct relocation_info {
   int32_t	r_address;	/* offset in the section to what is being
				   relocated */
   uint32_t     r_symbolnum:24,	/* symbol index if r_extern == 1 or section
				   ordinal if r_extern == 0 */
		r_pcrel:1, 	/* was relocated pc relative already */
		r_length:2,	/* 0=byte, 1=word, 2=long, 3=quad */
		r_extern:1,	/* does not include value of sym referenced */
		r_type:4;	/* if not 0, machine specific relocation type */
};

/*
 * r_type field of X86_64 architecture
 */
enum reloc_type_x86_64 {
	X86_64_RELOC_UNSIGNED,		// for absolute addresses
	X86_64_RELOC_SIGNED,		// for signed 32-bit displacement
	X86_64_RELOC_BRANCH,		// a CALL/JMP instruction with 32-bit displacement
	X86_64_RELOC_GOT_LOAD,		// a MOVQ load of a GOT entry
	X86_64_RELOC_GOT,			// other GOT references
	X86_64_RELOC_SUBTRACTOR,	// must be followed by a X86_64_RELOC_UNSIGNED
	X86_64_RELOC_SIGNED_1,		// for signed 32-bit displacement with a -1 addend
	X86_64_RELOC_SIGNED_2,		// for signed 32-bit displacement with a -2 addend
	X86_64_RELOC_SIGNED_4,		// for signed 32-bit displacement with a -4 addend
	X86_64_RELOC_TLV,		// for thread local variables
};
```



PC + x = ADDR(symbol)

x = ADDR(symbol) - PC

x = ADDR(symbol) - (reloc.offset + ADDR(reloc.section))

x = ADDR(symbol) - (reloc.offset + ADDR(reloc.section)) + reloc.addend



## **7.10** Dynamic Linking with Shared Libraries

Disadvantages of static libraries:

1. Every time the static libraries are updated, programmers need to relink their programme.
2. For a shared library that is used by many processes, its code segment is copied many times, unnecessarily taking up too much memory for read-only data.

Shared libraries address the disadvantages of static libraries. A shared library is an object module that can be loaded at any memory address and linked with any programme in memory at either load time or run time.



### Load time dynamic linking

![](https://raw.githubusercontent.com/Stevring/Pics/main/load_time_dynamic_linking.png)

### Run time dynamic linking

```C
/*
|-----------------------|
| __TEXT,__text         |
|-----------------------|
| __TEXT,__stubs        | // indirect pointers to symbol
|-----------------------|
| __TEXT,__stub_helper  | // code that prepares arguments for calling `dylb_stub_binder`,
|-----------------------| // address of which stored in the first entry of GOT
|					...           |
|-----------------------|
| __DATA_CONST,__got    | // global offset table
|-----------------------|
| __DATA,_la_symbol_ptr | // lasy-binding symbol pointers
|-----------------------|
| __DATA,__data         |
|-----------------------|
|         ...           |
|-----------------------|

*/
```



For a C programme:

```C
#include <stdio.h>

int main()
{
    int c = getchar();
    printf("%d", c);
    scanf("%d", &c);
    return c;
}
```



Before lazy-binding

![](https://raw.githubusercontent.com/Stevring/Pics/main/stubs_before_calling.png)



After lazy-binding

![](https://raw.githubusercontent.com/Stevring/Pics/main/stubs_after_calling.png)